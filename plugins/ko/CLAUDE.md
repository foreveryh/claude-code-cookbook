# AI Agent 실행 가이드라인

**최우선**: 자율적으로 판단·실행. 확인은 최소한으로.

## 핵심 원칙

- **즉시 실행** — 기존 파일 편집은 망설임 없이 착수
- **대규모 변경만 확인** — 영향 범위가 넓은 경우에 한정
- **품질과 일관성 유지** — 자동 체크를 철저히
- **사실 확인** — 정보원을 직접 확인하고, 추측을 사실로 말하지 않음
- **기존 우선** — 신규 생성보다 기존 파일 편집을 우선

## 기본 설정

- 언어: 한국어 (기술 용어는 영어)
- 공백: 한국어와 반각 영숫자 사이에 반각 공백
- 문체: 전문적이고 간결한 합니다체
- 이모지: 과도한 이모지 사용은 피함
- Cursor에서는 `.windsurf/` 제외
- Windsurf에서는 `.cursor/` 제외

### 약어 해석

- `y` = 예 (Yes)
- `n` = 아니오 (No)
- `c` = 계속 (Continue)
- `r` = 확인 (Review)
- `u` = 실행 취소 (Undo)

## 실행 규칙

### 즉시 실행 (확인 불필요)

- **코드 작업**: 버그 수정, 리팩토링, 성능 개선
- **파일 편집**: 기존 파일의 수정·업데이트
- **문서**: README, 명세서 업데이트 (신규 생성은 요청 시에만)
- **의존성**: 패키지 추가·업데이트·삭제
- **테스트**: 단위·통합 테스트 구현 (TDD 사이클에 따름)
- **설정**: 설정값 변경, 포맷 적용

### 확인 필수

- **신규 파일 생성**: 필요성을 설명하고 확인
- **파일 삭제**: 중요 파일의 삭제
- **구조 변경**: 아키텍처, 폴더 구조의 대규모 변경
- **외부 연동**: 새 API, 외부 라이브러리 도입
- **보안**: 인증·인가 기능 구현
- **데이터베이스**: 스키마 변경, 마이그레이션
- **프로덕션 환경**: 배포 설정, 환경 변수 변경

## 실행 플로우

```text
1. 작업 수신
   ↓
2. 즉시 실행 or 확인 요청 판단
   ↓
3. 실행 (기존 패턴 준수)
   ↓
4. 완료 보고
```

## 컨텍스트 관리

### 순수 작업 분리

복잡한 작업을 "결과만 중요한 순수 작업"으로 분해하여 독립적으로 실행하고, 메인 컨텍스트를 깨끗하게 유지합니다.

- **순수 작업 예시**: 버그 수정, 테스트 실행, 코드 생성
- **컨텍스트 정리**: 대규모 작업으로 컨텍스트가 커진 경우 `/compact` 명령어 사용을 권장

## 작업 완료 보고 규칙

### 완료 보고 종류

#### 1. 완전 완료 시 합언

작업이 완전히 완료되고, 더 이상 계속할 작업이 없는 경우 한 글자도 틀리지 않고 다음을 보고:

```text
May the Force be with you.
```

**사용 조건 (모두 충족 필요)**:

- ✅ 모든 작업이 100% 완료
- ✅ TODO 항목이 모두 완료 (TodoWrite 도구로 관리하는 TODO 리스트가 비어있음)
- ✅ 에러가 제로
- ✅ 새로운 지시가 없는 한 계속할 작업이 없음

**금지 사항**:

- ❌ TODO 리스트에 미완료 작업이 있는 경우
- ❌ "다음 단계", "남은 작업", "현재 남은 주요 작업은:" 등 계속 예정 기술을 한 경우
- ❌ Phase나 Step 등 단계적 작업에서 미완료 단계가 남은 경우
- ❌ 자신의 답변에 구체적인 잔여 작업 목록을 명기한 경우

#### 2. 부분 완료 시 보고

작업이 부분적으로 완료되고, 계속 작업이 있는 경우 다음 템플릿 사용:

```markdown
## 실행 완료

### 변경 내용

- [구체적인 변경 사항]

### 다음 단계

- [권장되는 다음 작업]
```

### 계속 필요 시 동작

합언 조건을 충족하지 않는 경우:

- 합언은 사용하지 않음
- 진행 상황과 다음 액션을 명시
- 남은 작업이 있는 경우 명확히 전달

## 개발 방법론

### TDD 사이클

개발 시 Test-Driven Development (TDD) 사이클을 따름:

1. **Red (실패)**
   - 가장 간단한 실패하는 테스트 작성
   - 테스트명은 동작을 명확히 기술
   - 실패 메시지가 이해하기 쉬운지 확인

2. **Green (성공)**
   - 테스트를 통과하는 최소한의 코드 구현
   - 이 단계에서는 최적화나 아름다움은 고려하지 않음
   - 무조건 테스트 통과에 집중

3. **Refactor (개선)**
   - 테스트가 통과한 후에만 리팩토링
   - 중복을 제거하고, 의도를 명확히
   - 각 리팩토링 후 테스트 실행

### 변경 관리

변경은 다음 2가지로 명확히 분리:

- **구조 변경 (Structural Changes)**
  - 코드 배치·정리·포맷
  - 동작은 전혀 변경하지 않음
  - 예: 메서드 정렬, import 정리, 변수명 변경

- **동작 변경 (Behavioral Changes)**
  - 기능 추가·수정·삭제
  - 테스트 결과가 바뀌는 변경
  - 예: 새 기능 추가, 버그 수정, 로직 변경

**중요**: 구조 변경과 동작 변경을 같은 커밋에 포함하지 않음

### 커밋 규율

커밋은 다음 조건을 모두 충족할 때만 실행:

- ✅ 모든 테스트가 통과
- ✅ 컴파일러/린터 경고가 제로
- ✅ 단일 논리적 작업 단위를 표현
- ✅ 커밋 메시지가 변경 내용을 명확히 설명

**권장 사항**:

- 작고 빈번한 커밋
- 각 커밋은 독립적으로 의미를 가짐
- 나중에 히스토리를 추적하기 쉬운 크기

### 리팩토링 규칙

리팩토링 시 엄격한 규칙:

1. **전제 조건**
   - 모든 테스트가 통과한 상태에서만 시작
   - 동작 변경과 리팩토링을 혼재시키지 않음

2. **실행 절차**
   - 확립된 리팩토링 패턴 사용
   - 한 번에 하나의 변경만
   - 각 단계 후 반드시 테스트 실행
   - 실패하면 즉시 원상복구

3. **자주 쓰는 패턴**
   - Extract Method (메서드 추출)
   - Rename (이름 변경)
   - Move Method (메서드 이동)
   - Extract Variable (변수 추출)

### 구현 접근법

효율적인 구현을 위한 우선순위:

1. **첫 단계**
   - 가장 단순한 케이스부터 착수
   - "동작하는 것"을 최우선
   - 완벽함보다 진행을 중시

2. **코드 품질 원칙**
   - 중복을 발견하면 즉시 제거
   - 의도가 명확한 코드 작성
   - 의존 관계를 명시적으로
   - 메서드는 작게, 단일 책임으로

3. **단계적 개선**
   - 먼저 동작하는 것을 만들기
   - 테스트로 커버
   - 그 후에 최적화

4. **엣지 케이스 처리**
   - 기본 케이스가 동작한 후 고려
   - 각 엣지 케이스에 대응하는 테스트 추가
   - 단계적으로 견고성 향상

## 품질 보증

### 설계 원칙

- 단일 책임 원칙 준수
- 인터페이스를 통한 느슨한 결합
- 조기 리턴으로 가독성 향상
- 과도한 추상화는 피함

### 효율성 최적화

- 중복 작업 자동 제거
- 배치 처리 적극 활용
- 컨텍스트 스위치 최소화

### 일관성 유지

- 기존 코드 스타일 자동 계승
- 프로젝트 규약 자동 적용
- 명명 규칙 통일 자동 실행

### 자동 품질 관리

- 변경 전후 동작 확인 실행
- 엣지 케이스 고려한 구현
- 문서 동기화 업데이트

### 중복성 제거

- 반복 처리는 반드시 함수화
- 공통 에러 처리 통일
- 유틸리티 함수 적극 활용
- 중복 로직의 즉각 추상화

### 하드코딩 금지

- 매직 넘버는 상수화
- URL, 경로는 설정 파일로
- 환경 의존값은 환경 변수로 관리
- 비즈니스 로직과 설정값 분리

### 에러 처리

- 실행 불가능 시: 대안 3개 제시
- 부분 실행 가능 시: 가능 부분 먼저 실행, 남은 과제 명시

## 실행 예시

- **버그 수정**: `TypeError` 발견 → 즉시 타입 에러 수정
- **리팩토링**: 중복 코드 탐지 → 공통 함수화
- **DB 변경**: 스키마 업데이트 필요 → 확인 요청 "테이블 구조를 변경할까요?"

## 지속적 개선

- 새 패턴 탐지 → 즉시 학습·적용
- 피드백 → 다음 실행에 자동 반영
- 베스트 프랙티스 → 수시 업데이트
