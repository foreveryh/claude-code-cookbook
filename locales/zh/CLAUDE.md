# AI 代理执行指南

**最重要**：自主判断与执行。最小化确认步骤。

## 核心原则

- **立即执行** — 毫不犹豫地着手编辑现有文件
- **仅大规模变更需确认** — 仅在影响范围广时进行确认
- **维持质量与一致性** — 彻底执行自动检查
- **事实确认** — 自行确认信息来源，不将猜测作为事实陈述
- **优先现有文件** — 优先编辑现有文件而非创建新文件

## 基本设置

- 语言：中文（技术术语使用英语）
- 空格：中文与半角英数字之间添加半角空格
- 文体：专业简洁，使用标准中文标点符号
- 表情符号：避免过度使用表情符号
- Cursor 中排除 `.windsurf/`
- Windsurf 中排除 `.cursor/`

### 缩写解释

- `y` = 是（Yes）
- `n` = 否（No）
- `c` = 继续（Continue）
- `r` = 确认（Review）
- `u` = 撤销（Undo）

## 执行规则

### 立即执行（无需确认）

- **代码操作**：Bug 修复、重构、性能改进
- **文件编辑**：现有文件的修改与更新
- **文档**：README、规范文档的更新（仅在要求时创建新文档）
- **依赖关系**：包的添加、更新与删除
- **测试**：单元测试与集成测试的实现（遵循 TDD 周期）
- **设置**：配置值更改、应用格式化

### 必须确认

- **创建新文件**：说明必要性并确认
- **删除文件**：重要文件的删除
- **结构变更**：架构、文件夹结构的大规模变更
- **外部集成**：新 API、外部库的引入
- **安全**：认证与授权功能的实现
- **数据库**： schema 变更、迁移
- **生产环境**：部署设置、环境变量变更

## 执行流程

```text
1. 接收任务
   ↓
2. 判断立即执行或请求确认
   ↓
3. 执行（遵循现有模式）
   ↓
4. 完成报告
```

## 上下文管理

### 纯任务隔离

将复杂任务分解为"只关注结果的纯任务"，独立执行以保持主上下文的清洁。

- **纯任务示例**：Bug 修复、测试执行、代码生成
- **上下文清理**：当大型工作导致上下文增长时，建议使用 `/compact` 命令

## 工作完成报告规则

### 完成报告类型

#### 1. 完全完成时的暗语

当工作完全完成且没有需要继续的任务时，必须一字不差地报告以下内容：

```text
May the Force be with you.
```

**使用条件（必须全部满足）**：

- ✅ 所有任务 100% 完成
- ✅ TODO 项目全部完成（TodoWrite 工具管理的 TODO 列表为空）
- ✅ 错误为零
- ✅ 没有不需要新指示就能继续的任务

**禁止事项**：

- ❌ TODO 列表中有未完成任务时
- ❌ 包含「下一步」「剩余任务」「目前剩余的主要任务是：」等计划继续的描述时
- ❌ Phase 或 Step 等阶段性工作中有未完成阶段时
- ❌ 在回答中明确列出具体剩余工作清单时

#### 2. 部分完成时的报告

当工作部分完成且有后续任务时，使用以下模板：

```markdown
## 执行完成

### 变更内容

- [具体变更点]

### 下一步

- [推荐的后续工作]
```

### 需要继续时的动作

不满足暗语条件时：

- 不使用暗语
- 明确说明进展情况和下一步行动
- 如有剩余任务，明确传达

## 开发方法

### TDD 周期

开发时遵循测试驱动开发 (TDD) 周期：

1. **Red（失败）**

   - 编写最简单的失败测试
   - 测试名称明确描述行为
   - 确保失败消息易于理解

2. **Green（成功）**

   - 实现通过测试的最小代码
   - 此阶段不考虑优化和美观
   - 专注于让测试通过

3. **Refactor（改进）**
   - 仅在测试通过后进行重构
   - 消除重复，明确意图
   - 每次重构后执行测试

### 变更管理

变更明确分为以下两种类型：

- **结构变更（Structural Changes）**

  - 代码的排列、整理、格式化
  - 完全不改变行为
  - 例如：方法重排、导入整理、变量名变更

- **行为变更（Behavioral Changes）**
  - 功能的添加、修改、删除
  - 会改变测试结果的变更
  - 例如：添加新功能、修复错误、更改逻辑

**重要**：不要在同一提交中包含结构变更和行为变更

### 提交纪律

仅当满足以下所有条件时执行提交：

- ✅ 所有测试通过
- ✅ 编译器/Linter 警告为零
- ✅ 代表单一逻辑工作单元
- ✅ 提交消息明确说明变更内容

**推荐事项**：

- 小而频繁的提交
- 每个提交独立有意义
- 粒度便于日后追溯历史

### 重构规则

重构时的严格规则：

1. **前提条件**

   - 仅在所有测试通过的状态下开始
   - 不混合行为变更和重构

2. **执行步骤**

   - 使用已确立的重构模式
   - 一次仅进行一项变更
   - 每步后务必执行测试
   - 失败时立即回滚

3. **常用模式**
   - 提取方法（Extract Method）
   - 重命名（Rename）
   - 移动方法（Move Method）
   - 提取变量（Extract Variable）

### 实现方法

为高效实现，按以下优先级：

1. **第一步**

   - 从最简单的情况入手
   - 优先考虑「能运行」
   - 重视进展而非完美

2. **代码质量原则**

   - 发现重复立即消除
   - 编写意图明确的代码
   - 明确依赖关系
   - 方法小且单一职责

3. **逐步改进**

   - 先让代码运行
   - 测试覆盖
   - 后续优化

4. **边缘情况处理**
   - 基本情况运行后再考虑
   - 为每个边缘情况添加对应测试
   - 逐步提高健壮性

## 质量保证

### 设计原则

- 遵守单一职责原则
- 通过接口实现松耦合
- 通过早期返回提高可读性
- 避免过度抽象

### 效率优化

- 自动消除重复工作
- 积极使用批处理
- 最小化上下文切换

### 一致性维护

- 自动继承现有代码风格
- 自动应用项目规约
- 自动执行命名规则统一

### 自动质量管理

- 执行变更前后的行为确认
- 实现边缘情况考虑
- 文档同步更新

### 冗余消除

- 重复处理必须函数化
- 统一通用错误处理
- 积极使用工具函数
- 立即抽象重复逻辑

### 禁止硬编码

- 魔术数字常量化
- URL、路径放入配置文件
- 环境依赖值用环境变量管理
- 业务逻辑与配置值分离

### 错误处理

- 无法执行时：提供 3 个替代方案
- 可部分执行时：先执行可能部分，明确剩余问题

## 执行示例

- **Bug 修复**：发现 `TypeError` → 立即修正类型错误
- **重构**：检测到重复代码 → 提取为共通函数
- **DB 变更**：需要更新架构 → 确认请求「是否变更表结构？」

## 持续改进

- 检测新模式 → 立即学习和应用
- 反馈 → 自动反映到下次执行
- 最佳实践 → 随时更新
