# AI 代理執行指南

**最重要**：自主判斷與執行。最小化確認步驟。

## 核心原則

- **立即執行** — 毫不猶豫地著手編輯現有檔案
- **僅大規模變更需確認** — 僅在影響範圍廣時進行確認
- **維持品質與一致性** — 徹底執行自動檢查
- **事實確認** — 自行確認資訊來源，不將猜測作為事實陳述
- **優先現有檔案** — 優先編輯現有檔案而非建立新檔案

## 基本設定

- 語言：中文（技術術語使用英語）
- 空格：中文與半形英數字之間新增半形空格
- 文體：專業簡潔，使用標準中文標點符號
- 表情符號：避免過度使用表情符號
- Cursor 中排除 `.windsurf/`
- Windsurf 中排除 `.cursor/`

### 縮寫解釋

- `y` = 是（Yes）
- `n` = 否（No）
- `c` = 繼續（Continue）
- `r` = 確認（Review）
- `u` = 撤銷（Undo）

## 執行規則

### 立即執行（無需確認）

- **程式碼操作**：Bug 修復、重構、效能改進
- **檔案編輯**：現有檔案的修改與更新
- **文件**：README、規範文件的更新（僅在要求時建立新文件）
- **相依關係**：套件的新增、更新與刪除
- **測試**：單元測試與整合測試的實作（遵循 TDD 週期）
- **設定**：設定值變更、套用格式化

### 必須確認

- **建立新檔案**：說明必要性並確認
- **刪除檔案**：重要檔案的刪除
- **結構變更**：架構、資料夾結構的大規模變更
- **外部整合**：新 API、外部程式庫的引入
- **安全**：認證與授權功能的實作
- **資料庫**： schema 變更、遷移
- **生產環境**：部署設定、環境變數變更

## 執行流程

```text
1. 接收任務
   ↓
2. 判斷立即執行或請求確認
   ↓
3. 執行（遵循現有模式）
   ↓
4. 完成報告
```

## 上下文管理

### 純任務隔離

將複雜任務分解為「只關注結果的純任務」，獨立執行以保持主上下文的清潔。

- **純任務範例**：Bug 修復、測試執行、程式碼產生
- **上下文清理**：當大型工作導致上下文增長時，建議使用 `/compact` 指令

## 工作完成報告規則

### 完成報告類型

#### 1. 完全完成時的暗語

當工作完全完成且沒有需要繼續的任務時，必須一字不差地報告以下內容：

```text
May the Force be with you.
```

**使用條件（必須全部滿足）**：

- ✅ 所有任務 100% 完成
- ✅ TODO 項目全部完成（TodoWrite 工具管理的 TODO 清單為空）
- ✅ 錯誤為零
- ✅ 沒有不需要新指示就能繼續的任務

**禁止事項**：

- ❌ TODO 清單中有未完成任務時
- ❌ 包含「下一步」「剩餘任務」「目前剩餘的主要任務是：」等計劃繼續的描述時
- ❌ Phase 或 Step 等階段性工作中有未完成階段時
- ❌ 在回答中明確列出具體剩餘工作清單時

#### 2. 部分完成時的報告

當工作部分完成且有後續任務時，使用以下模板：

```markdown
## 執行完成

### 變更內容

- [具體變更點]

### 下一步

- [推薦的後續工作]
```

### 需要繼續時的動作

不滿足暗語條件時：

- 不使用暗語
- 明確說明進展情況和下一步行動
- 如有剩餘任務，明確傳達

## 開發方法

### TDD 週期

開發時遵循測試驅動開發 (TDD) 週期：

1. **Red（失敗）**

   - 編寫最簡單的失敗測試
   - 測試名稱明確描述行為
   - 確保失敗訊息易於理解

2. **Green（成功）**

   - 實作通過測試的最小程式碼
   - 此階段不考慮最佳化和美觀
   - 專注於讓測試通過

3. **Refactor（改進）**
   - 僅在測試通過後進行重構
   - 消除重複，明確意圖
   - 每次重構後執行測試

### 變更管理

變更明確分為以下兩種類型：

- **結構變更（Structural Changes）**

  - 程式碼的排列、整理、格式化
  - 完全不改變行為
  - 例如：方法重排、匯入整理、變數名稱變更

- **行為變更（Behavioral Changes）**
  - 功能的新增、修改、刪除
  - 會改變測試結果的變更
  - 例如：新增新功能、修復錯誤、更改邏輯

**重要**：不要在同一提交中包含結構變更和行為變更

### 提交紀律

僅當滿足以下所有條件時執行提交：

- ✅ 所有測試通過
- ✅ 編譯器/Linter 警告為零
- ✅ 代表單一邏輯工作單元
- ✅ 提交訊息明確說明變更內容

**推薦事項**：

- 小而頻繁的提交
- 每個提交獨立有意義
- 粒度便於日後追溯歷史

### 重構規則

重構時的嚴格規則：

1. **前提條件**

   - 僅在所有測試通過的狀態下開始
   - 不混合行為變更和重構

2. **執行步驟**

   - 使用已確立的重構模式
   - 一次僅進行一項變更
   - 每步後務必執行測試
   - 失敗時立即回滾

3. **常用模式**
   - 提取方法（Extract Method）
   - 重新命名（Rename）
   - 移動方法（Move Method）
   - 提取變數（Extract Variable）

### 實作方法

為高效實作，按以下優先級：

1. **第一步**

   - 從最簡單的情況入手
   - 優先考慮「能運行」
   - 重視進展而非完美

2. **程式碼品質原則**

   - 發現重複立即消除
   - 編寫意圖明確的程式碼
   - 明確相依關係
   - 方法小且單一職責

3. **逐步改進**

   - 先讓程式碼運行
   - 測試覆蓋
   - 後續最佳化

4. **邊緣情況處理**
   - 基本情況運行後再考慮
   - 為每個邊緣情況新增對應測試
   - 逐步提高健壯性

## 品質保證

### 設計原則

- 遵守單一職責原則
- 通過介面實現鬆耦合
- 通過早期返回提高可讀性
- 避免過度抽象

### 效率最佳化

- 自動消除重複工作
- 積極使用批次處理
- 最小化上下文切換

### 一致性維護

- 自動繼承現有程式碼風格
- 自動應用專案規約
- 自動執行命名規則統一

### 自動品質管理

- 執行變更前後的行為確認
- 實作邊緣情況考慮
- 文件同步更新

### 冗餘消除

- 重複處理必須函數化
- 統一通用錯誤處理
- 積極使用工具函數
- 立即抽象重複邏輯

### 禁止硬編碼

- 魔術數字常數化
- URL、路徑放入設定檔案
- 環境相依值用環境變數管理
- 業務邏輯與設定值分離

### 錯誤處理

- 無法執行時：提供 3 個替代方案
- 可部分執行時：先執行可能部分，明確剩餘問題

## 執行範例

- **Bug 修復**：發現 `TypeError` → 立即更正類型錯誤
- **重構**：檢測到重複程式碼 → 提取為共通函數
- **DB 變更**：需要更新架構 → 確認請求「是否變更表結構？」

## 持續改進

- 檢測新模式 → 立即學習和應用
- 反饋 → 自動反映到下次執行
- 最佳實務 → 隨時更新
